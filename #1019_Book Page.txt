#1019 책 페이지
I=input()
l=len(I)
L=[0 for i in range(10)]
#각 숫자가 나타나는 횟수, 정답을 저장할 공간
if l==1:
  #밑의 마지막자리 처리하는 if문에서 0을 제외해주는 한 자리수 예외처리가 필요함
  for j in range(1,int(I[0])+1):
    L[j]+=1
else:
  for i in range(l):
    #Ex. 2047
    
    if i==l-1:
      #마지막이 0으로 끝날 때 아래 if문 처리에 대해서 예외로 해야하기 때문에 선행하여 마지막 자리 따로 처리
      for j in range(int(I[-1])+1):
        L[j]+=1
      continue
    
    if int(I[i])==0: #0인 경우에는 0 개수 그 아래 수 만큼 더해주고 pass
      #Ex. 20__:00~47
      L[0]+=int(I[i+1:])+1
      continue
  
    for j in range(10):
      #2047에서 i=0이라 치면 2000까지 가는데에 아래에서 돌아간 횟수
      L[j]+=int(I[i])*(l-i-1)*(10**(l-i-2))
    
    if i==0: #0에 대한 예외처리는 첫자리에서 첫 자리가 0이라 가정할 때 오바되는 것 만큼 빼주고 시작하면 됨
      for k in range(1,int(I[i])): 
        #해당 자리의 수가 그 밑자리수만큼 나오는 것을 더해줌 (이때 0까지 포함시키고 0은 추후에 후처리)
      #Ex. 0___:미포함, 1---: L[1]+=1000, L[2]+=48 000~047
        L[k]+=10**(l-i-1)
      L[int(I[i])]+=int(I[i+1:])+1
      
      for j in range(1,l-i): #0 후처리 맨앞자리가 0일때(0___) 밑에서 돌아갈 때 원래 돌아갔던 전체수 만큼 더해주고
        L[0]+=9*j*(10**(j-1))
      L[0]-=(l-i-1)*(10**(l-i-1)) #0에서 오바되서 넘쳐난 전체수를 빼주기
    else:
      for k in range(int(I[i])): 
        #해당 자리의 수가 그 밑자리수만큼 나오는 것을 더해줌 (이때 0까지 포함시키고 0은 추후에 후처리)
      #Ex. ?0___:포함, 1---: L[1]+=1000, L[2]+=48 000~047
        L[k]+=10**(l-i-1)
      L[int(I[i])]+=int(I[i+1:])+1
  
print(" ".join(map(str,L)))


#X0~X9의 꼴로 만들어서 규칙성있게 처리하고 그 외의 부분을 처리해줘도 가능. 시간복잡도상으론 비슷. 발상은 위가 생각하기 더 쉬운데 자리수나 0에 대한 예외처리 관련해서 꼼꼼하게 해줘야함.