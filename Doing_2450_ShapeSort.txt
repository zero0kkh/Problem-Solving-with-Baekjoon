#2450 모양 정돈
n=int(input())
l=list(map(int,input().split()))
L=[]
cnt=0
for i in range(n-1):
  if cnt==0:
    cnt=1
    L.append([l[i],cnt])
  if l[i]==l[i+1]:
    L[-1][1]+=1
  else:
    cnt=0
if l[-1]!=l[-2]:
  L.append([l[-1],1])
ind=n-1
while ind<n-1:
  shape,length=L[ind]
  M=length #max length
  I=ind #max index
  for i in range(len(L)):
    if L[i][0]==shape and L[i][1]>=M:
      M=L[i][1]
      I=i
  if I==ind: ind+=1
  else:
    L[I][1]+=1
    cnt+=1
    if I>0 and L[I-1][0] == L[ind+1][0] and L[I-1][1]<L[ind+1][1]:
      L[ind+1]
      
            
  
      
  

'''
(1,1)(3,2)(2,1)(1,2)(3,1)(2,1)
-(1,1)을 (1,2)근처로 보내는 데, 만약 (3,)이 있으면 그 친구랑 바꿈
(3,3)(2,1)(1,3)(2,1)

만약 없고 (4,1)이었다면
(4,1)(3,2)(2,1)(1,3)(2,1)
or
(2,1)(3,2)(1,3)(4,1)(2,1)

greedy: 가장 끝의 max가 아닌 부분을 무조건 해당 종류의 부분들중 가장 긴(max) component에 합쳐버림. (등호포함 max)
그때 보낼 때 2번째꺼랑 붙을 수 있는 거면 그걸 우선으로
=>swap을 고려해서 바로 합치지 말고 1개씩 옮기기

DS 생각을 해주어야할 듯. 나중에.

'''
